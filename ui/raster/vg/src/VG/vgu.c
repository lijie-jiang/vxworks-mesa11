/* vgu.c - Wind River VG Utility Functionality */

/*
 * Copyright (c) 2013-2014 Wind River Systems, Inc.
 *
 * The right to copy, distribute, modify or otherwise make use
 * of this software may be licensed only pursuant to the terms
 * of an applicable Wind River License agreement.
 */

/*
modification history
--------------------
22dec14,yat  Fix build warning for LP64 (US50456)
14aug13,mgc  Modified for VxWorks 7 release
13feb12,m_c  Released to Wind River engineering
26may09,m_c  Written using code from the reference implementation
*/

/*
DESCRIPTION
These routines provide utility functionality that support the OpenVG
implementation.  The implementation is based on the Khronos OpenVG 1.1
Reference Implementation
*/

/*------------------------------------------------------------------------
 *
 * VGU library for OpenVG 1.1 Reference Implementation
 * ---------------------------------------------------
 *
 * Copyright (c) 2007 The Khronos Group Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and /or associated documentation files
 * (the "Materials "), to deal in the Materials without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Materials,
 * and to permit persons to whom the Materials are furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Materials.
 *
 * THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE MATERIALS OR
 * THE USE OR OTHER DEALINGS IN THE MATERIALS.
 *
 *//**
 * \file
 * \brief   Implementation of the VGU utility library for OpenVG
 *//*-------------------------------------------------------------------*/

/* includes */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <EGL/eglimpl.h>
#include <VG/vgimpl.h>
#include <VG/vgu.h>

/* defines */

/* Clamp */
#define CLAMP(_x, _l, _h)           if ((_x) < (_l)) _x = _l; else if ((_x) > (_h)) _x = _h
#define CLAMP_ANGLE(_angle, _l, _h) do                          \
                                        {                       \
                                        while ((_angle) < (_l)) \
                                            _angle += TWO_PI;   \
                                        while ((_angle) > (_h)) \
                                            _angle -= TWO_PI;   \
                                        } while (0)

/* Maximum number of coordinates generated by the VGU functions */
#define MAX_COORDS                  26

/* forward declarations */

LOCAL void  append(VGPath, int, const VGubyte*, int, const VGfloat*);

/*******************************************************************************
 *
 * append - convert and append data to the specified path
 *
 */
LOCAL void append
    (
    VGPath path,
    int numSegments,
    const VGubyte* segments,
    int numCoords,
    const VGfloat* coords
    )
    {
    _VGType                         buf[MAX_COORDS];
    int                             i;
    VGint                           datatype;       /* path datatype */
    VGfloat                         scale, bias;    /* path scale and bias */

    datatype = vgGetParameteri(path, VG_PATH_DATATYPE);
    scale = vgGetParameterf(path, VG_PATH_SCALE);
    bias = vgGetParameterf(path, VG_PATH_BIAS);
    switch(datatype)
        {
        case VG_PATH_DATATYPE_S_8:
            {
            VGbyte* data = (VGbyte*)buf;
            for (i = 0; i < numCoords; i++)
                data[i] = (VGbyte)floor((double)(((coords[i] - bias) / scale) + 0.5f));
            vgAppendPathData(path, numSegments, segments, data);
            break;
            }

        case VG_PATH_DATATYPE_S_16:
            {
            VGshort* data = (VGshort*)buf;
            for (i = 0; i < numCoords; i++)
                data[i] = (VGshort)floor((double)(((coords[i] - bias) / scale) + 0.5f));
            vgAppendPathData(path, numSegments, segments, data);
            break;
            }

        case VG_PATH_DATATYPE_S_32:
            {
            VGint* data = (VGint*)buf;
            for (i = 0; i < numCoords; i++)
                data[i] = (VGint)floor((double)(((coords[i] - bias) / scale) + 0.5f));
            vgAppendPathData(path, numSegments, segments, data);
            break;
            }

        case VG_PATH_DATATYPE_F:
            {
            VGfloat* data = (VGfloat*)buf;
            for (i = 0; i < numCoords; i++)
                data[i] = (coords[i] - bias) / scale;
            vgAppendPathData(path, numSegments, segments, data);
            break;
            }
        }
    }

/*******************************************************************************
 *
 * vguArc
 *
 */
VGU_API_CALL VGUErrorCode VGU_API_ENTRY vguArc
    (
    VGPath path,
    VGfloat x,
    VGfloat y,
    VGfloat width,
    VGfloat height,
    VGfloat startAngle,
    VGfloat angleExtent,
    VGUArcType arcType
    ) VGU_API_EXIT
    {
    VGfloat                         angle;          /* angle */
    VGfloat                         coords[7];      /* path coordinates */
    VGfloat                         endAngle;       /* end angle */
    VGubyte                         segments[3];    /* path segments */

    /* Check arguments */
    if ((width <= 0) || (height <= 0))
        return (VGU_ILLEGAL_ARGUMENT_ERROR);

    if ((arcType < VGU_ARC_OPEN) || (arcType > VGU_ARC_PIE))
        return (VGU_ILLEGAL_ARGUMENT_ERROR);

    /* Adjust parameters */
    width /= 2.0f;
    height /= 2.0f;
    startAngle = DEG_TO_RAD(startAngle);
    CLAMP_ANGLE(startAngle, 0, TWO_PI);
    angleExtent = DEG_TO_RAD(angleExtent);

    /* Calculate the end angle */
    endAngle = startAngle + angleExtent;

    /*
     * Initialize and append data. For details about the logic, see the pseudo
     * code in specifications, section "17.1.6 Arcs",page 206
     */
    segments[0] = VG_MOVE_TO_ABS;
    coords[0] = x + (width * (VGfloat)cos((double)startAngle));
    coords[1] = y + (height * (VGfloat)sin((double)startAngle));
    append(path, 1, segments, 2, coords);
    coords[0] = width;
    coords[1] = height;
    coords[2] = 0.0f;
    if (angleExtent >= 0.0f)
        {
        segments[0] = VG_SCCWARC_TO_ABS;
        for (angle = startAngle + PI; angle < endAngle; angle += PI)
            {
            coords[3] = x + (width * (VGfloat)cos((double)angle));
            coords[4] = y + (height * (VGfloat)sin((double)angle));
            append(path, 1, segments, 5, coords);
            }
        }
    else
        {
        segments[0] = VG_SCWARC_TO_ABS;
        for (angle = startAngle - PI; angle > endAngle; angle -= PI)
            {
            coords[3] = x + (width * (VGfloat)cos((double)angle));
            coords[4] = y + (height * (VGfloat)sin((double)angle));
            append(path, 1, segments, 5, coords);
            }
        }
    coords[3] = x + (width * (VGfloat)cos((double)endAngle));
    coords[4] = y + (height * (VGfloat)sin((double)endAngle));
    if (arcType == VGU_ARC_CHORD)
        {
        segments[1] = VG_CLOSE_PATH;
        append(path, 2, segments, 5, coords);
        }
    else if (arcType == VGU_ARC_PIE)
        {
        segments[1] = VG_LINE_TO_ABS;
        coords[5] = x;
        coords[6] = y;
        segments[2] = VG_CLOSE_PATH;
        append(path, 3, segments, 7, coords);
        }
    else
        append(path, 1, segments, 5, coords);

    /* Convert error */
    switch (vgGetError())
        {
        case VG_BAD_HANDLE_ERROR:
            return (VGU_BAD_HANDLE_ERROR);

        case VG_PATH_CAPABILITY_ERROR:
            return (VGU_PATH_CAPABILITY_ERROR);

        case VG_OUT_OF_MEMORY_ERROR:
            return (VGU_OUT_OF_MEMORY_ERROR);

        default:
            return (VGU_NO_ERROR);
        }
    }

/*******************************************************************************
 *
 * vguComputeWarpQuadToSquare
 *
 */
VGU_API_CALL VGUErrorCode VGU_API_ENTRY vguComputeWarpQuadToQuad
    (
    VGfloat dx0,
    VGfloat dy0,
    VGfloat dx1,
    VGfloat dy1,
    VGfloat dx2,
    VGfloat dy2,
    VGfloat dx3,
    VGfloat dy3,
    VGfloat sx0,
    VGfloat sy0,
    VGfloat sx1,
    VGfloat sy1,
    VGfloat sx2,
    VGfloat sy2,
    VGfloat sx3,
    VGfloat sy3,
    VGfloat* matrix
    ) VGU_API_EXIT
    {
    VGfloat temp[9];        /* intermediate matrix */
    int     i;
    float   e00, e01, e02;  /* matrix individual elements */
    float   e10, e11, e12;
    float   e20, e21, e22;

    /* Check arguments */
    if (isInvalidPtr(matrix, sizeof(VGfloat)))
        return (VGU_ILLEGAL_ARGUMENT_ERROR);

    /* Calculate the warping transformations to and from the unit square...*/
    if (vguComputeWarpQuadToSquare(sx0, sy0, sx1, sy1, sx2, sy2, sx3, sy3, temp) == VGU_BAD_WARP_ERROR)
        return (VGU_BAD_WARP_ERROR);
    if(vguComputeWarpSquareToQuad(dx0, dy0, dx1, dy1, dx2, dy2, dx3, dy3, matrix) == VGU_BAD_WARP_ERROR)
        return (VGU_BAD_WARP_ERROR);
    /* ...and combine them */
    e00 = matrix[0], e01 = matrix[1], e02 = matrix[2];
    e10 = matrix[3], e11 = matrix[4], e12 = matrix[5];
    e20 = matrix[6], e21 = matrix[7], e22 = matrix[8];
    for (i = 0; i < 9; i += 3)
        {
        matrix[i + 0] = (temp[i + 0] * e00) + (temp[i + 1] * e10) + (temp[i + 2] * e20);
        matrix[i + 1] = (temp[i + 0] * e01) + (temp[i + 1] * e11) + (temp[i + 2] * e21);
        matrix[i + 2] = (temp[i + 0] * e02) + (temp[i + 1] * e12) + (temp[i + 2] * e22);
        }
    return (VGU_NO_ERROR);
    }


/*******************************************************************************
 *
 * vguComputeWarpQuadToSquare
 *
 */
VGU_API_CALL VGUErrorCode VGU_API_ENTRY vguComputeWarpQuadToSquare
    (
    VGfloat sx0,
    VGfloat sy0,
    VGfloat sx1,
    VGfloat sy1,
    VGfloat sx2,
    VGfloat sy2,
    VGfloat sx3,
    VGfloat sy3,
    VGfloat* matrix
    ) VGU_API_EXIT
    {
    VGfloat temp[9];    /* intermediate matrix */

    /* Check arguments */
    if (isInvalidPtr(matrix, sizeof(VGfloat)))
        return VGU_ILLEGAL_ARGUMENT_ERROR;

    /* Calculate the matrix that maps the unit square to the specified quad...*/
    if (vguComputeWarpSquareToQuad(sx0, sy0, sx1, sy1, sx2, sy2, sx3, sy3, temp) == VGU_BAD_WARP_ERROR)
        return (VGU_BAD_WARP_ERROR);
    /* ...and get the inverse transformation */
    if (invert3x3(temp, matrix))
        return (VGU_BAD_WARP_ERROR);
    else
        return (VGU_NO_ERROR);
    }

/*******************************************************************************
 *
 * vguComputeWarpSquareToQuad
 *
 */
VGU_API_CALL VGUErrorCode VGU_API_ENTRY vguComputeWarpSquareToQuad
    (
    VGfloat dx0,
    VGfloat dy0,
    VGfloat dx1,
    VGfloat dy1,
    VGfloat dx2,
    VGfloat dy2,
    VGfloat dx3,
    VGfloat dy3,
    VGfloat* matrix
    ) VGU_API_EXIT
    {
    VGfloat                         ax, ay;
    VGfloat                         bx, by;
    VGfloat                         det;
    VGfloat                         g, h;
    VGfloat                         p, q;

    /* Check arguments */
    if (isInvalidPtr(matrix, sizeof(VGfloat)))
        return (VGU_ILLEGAL_ARGUMENT_ERROR);

    /*
     * See Paul Heckbert's Master's Thesis, "Fundamentals of Texture Mapping
     * and Image Warping", page 71 for the explanations and original code
     */
    p = dx0 - dx1 + dx3 - dx2;
    q = dy0 - dy1 + dy3 - dy2;
    if ((p == 0.0) && (q == 0.0))
        {
        matrix[0] = dx1 - dx0;
        matrix[1] = dy1 - dy0;
        matrix[2] = matrix[5] = 0.0;
        matrix[3] = dx3 - dx1;
        matrix[4] = dy3 - dy1;
        matrix[6] = dx0;
        matrix[7] = dy0;
        matrix[8] = 1.0;
        }
    else
        {
        ax = dx1 - dx3;
        ay = dy1 - dy3;
        bx = dx2 - dx3;
        by = dy2 - dy3;
        det = (ax * by) - (bx * ay);
        if (det == 0.0)
            return (VGU_BAD_WARP_ERROR);
        else
            {
            g = ((p * by) - (bx * q)) / det;
            h = ((ax * q) - (p * ay)) / det;
            matrix[0] = dx1 - dx0 + (g * dx1);
            matrix[1] = dy1 - dy0 + (g * dy1);
            matrix[2] = g;
            matrix[3] = dx2 - dx0 + (h * dx2);
            matrix[4] = dy2 - dy0 + (h * dy2);
            matrix[5] = h;
            matrix[6] = dx0;
            matrix[7] = dy0;
            matrix[8] = 1.0;
            }
        }
    return (VGU_NO_ERROR);
    }

/*******************************************************************************
 *
 * vguEllipse
 *
 */
VGU_API_CALL VGUErrorCode VGU_API_ENTRY vguEllipse
    (
    VGPath path,
    VGfloat cx,
    VGfloat cy,
    VGfloat width,
    VGfloat height
    ) VGU_API_EXIT
    {
    VGfloat                 coords[12];                      /* path coordinates */
    static const VGubyte    segments[4] =  {VG_MOVE_TO_ABS,  /* path segments */
                                           VG_SCCWARC_TO_ABS,
                                           VG_SCCWARC_TO_ABS,
                                           VG_CLOSE_PATH};

    /* Check arguments */
    if ((width <= 0) || (height <= 0))
        return (VGU_ILLEGAL_ARGUMENT_ERROR);

    /* Clear error state */
    (void) vgGetError();

    /* Adjust parameters */
    width /= 2;
    height /= 2;

    /* Initialize the data */
    coords[0] = cx + width;
    coords[1] = cy;
    coords[2] = width;
    coords[3] = height;
    coords[4] = 0.0;
    coords[5] = cx - width;
    coords[6] = cy;
    coords[7] = width;
    coords[8] = height;
    coords[9] = 0.0;
    coords[10] = cx + width;
    coords[11] = cy;

    /* Append to the path */
    append(path, 4, segments, 12, coords);

    /* Convert error */
    switch (vgGetError())
        {
        case VG_BAD_HANDLE_ERROR:
            return (VGU_BAD_HANDLE_ERROR);

        case VG_PATH_CAPABILITY_ERROR:
            return (VGU_PATH_CAPABILITY_ERROR);

        case VG_OUT_OF_MEMORY_ERROR:
            return (VGU_OUT_OF_MEMORY_ERROR);

        default:
            return (VGU_NO_ERROR);
        }
    }


/*******************************************************************************
 *
 * vguPolygon
 *
 */
VGU_API_CALL VGUErrorCode VGU_API_ENTRY vguPolygon
    (
    VGPath path,
    const VGfloat* points,
    VGint count,
    VGboolean closed
    ) VGU_API_EXIT
    {
    VGfloat                         coords[2];      /* path coordinates */
    int                             i;
    VGubyte                         segments[1];    /* path segments */

    /* Check arguments */
    if (isInvalidPtr(points, sizeof(VGfloat)))
        return (VGU_ILLEGAL_ARGUMENT_ERROR);

    if (count <= 0)
        return (VGU_ILLEGAL_ARGUMENT_ERROR);

    /* Clear error state */
    (void) vgGetError();

    /* Append to the path */
    segments[0] = VG_MOVE_TO_ABS;
    for(i= 0; i < count; i++)
        {
        coords[0] = points[(i * 2) + 0];
        coords[1] = points[(i * 2) + 1];
        append(path, 1, segments, 2, coords);
        segments[0] = VG_LINE_TO_ABS;
        }
    if (closed)
        {
        segments[0] = VG_CLOSE_PATH;
        append(path, 1, segments, 0, coords);
        }

    /* Convert error */
    switch (vgGetError())
        {
        case VG_BAD_HANDLE_ERROR:
            return (VGU_BAD_HANDLE_ERROR);

        case VG_PATH_CAPABILITY_ERROR:
            return (VGU_PATH_CAPABILITY_ERROR);

        case VG_OUT_OF_MEMORY_ERROR:
            return (VGU_OUT_OF_MEMORY_ERROR);

        default:
            return (VGU_NO_ERROR);
        }
    }

/*******************************************************************************
 *
 * vguRect
 *
 */
VGU_API_CALL VGUErrorCode VGU_API_ENTRY vguRect
    (
    VGPath path,
    VGfloat x,
    VGfloat y,
    VGfloat width,
    VGfloat height
    ) VGU_API_EXIT
    {
    VGfloat                 coords[5];                      /* path coordinates */
    static const VGubyte    segments[5] = {VG_MOVE_TO_ABS,  /* path segments */
                                           VG_HLINE_TO_ABS,
                                           VG_VLINE_TO_ABS,
                                           VG_HLINE_TO_ABS,
                                           VG_CLOSE_PATH};

    /* Check arguments */
    if ((width <= 0) || (height <= 0))
        return (VGU_ILLEGAL_ARGUMENT_ERROR);

    /* Clear error state */
    (void) vgGetError();

    /* Initialize the data */
    coords[0] = coords[4] = x;
    coords[1] = y;
    coords[2] = x + width;
    coords[3] = y + height;

    /* Append to the path */
    append(path, 5, segments, 5, coords);

    /* Convert error */
    switch (vgGetError())
        {
        case VG_BAD_HANDLE_ERROR:
            return (VGU_BAD_HANDLE_ERROR);

        case VG_PATH_CAPABILITY_ERROR:
            return (VGU_PATH_CAPABILITY_ERROR);

        case VG_OUT_OF_MEMORY_ERROR:
            return (VGU_OUT_OF_MEMORY_ERROR);

        default:
            return (VGU_NO_ERROR);
        }
    }

/*******************************************************************************
 *
 * vguRoundRect
 *
 */
VGU_API_CALL VGUErrorCode VGU_API_ENTRY vguRoundRect
    (
    VGPath path,
    VGfloat x,
    VGfloat y,
    VGfloat width,
    VGfloat height,
    VGfloat arcWidth,
    VGfloat arcHeight
    ) VGU_API_EXIT
    {
    VGfloat                 coords[26];                     /* path coordinates */
    static const VGubyte    segments[10] = {VG_MOVE_TO_ABS, /* path segments */
                                           VG_HLINE_TO_ABS,
                                           VG_SCCWARC_TO_ABS,
                                           VG_VLINE_TO_ABS,
                                           VG_SCCWARC_TO_ABS,
                                           VG_HLINE_TO_ABS,
                                           VG_SCCWARC_TO_ABS,
                                           VG_VLINE_TO_ABS,
                                           VG_SCCWARC_TO_ABS,
                                           VG_CLOSE_PATH};

    /* Check arguments */
    if ((width <= 0) || (height <= 0))
        return (VGU_ILLEGAL_ARGUMENT_ERROR);

    /* Clear error state */
    (void) vgGetError();

    /* Adjust parameters */
    CLAMP(arcWidth, 0, width);
    arcWidth /= 2;
    CLAMP(arcHeight, 0, height);
    arcHeight /= 2;

    /* Initialize the data */
    coords[0] = coords[14] = coords[24] = x + arcWidth;
    coords[1] = coords[25] = y;
    coords[2] = x + width - arcWidth;
    coords[3] = coords[9] = coords[15] = coords[21] = arcWidth;
    coords[4] = coords[10] = coords[16] = coords[22] = arcHeight;
    coords[5] = coords[11] = coords[17] = coords[23] = 0.0;
    coords[6] = x + width;
    coords[7] = coords[20] = y + arcHeight;
    coords[8] = coords[19] = y + height - arcHeight;
    coords[12] = x + width - arcWidth;
    coords[13] = y + height;
    coords[18] = x;

    /* Append to the path */
    append(path, 10, segments, 26, coords);

    /* Convert error */
    switch (vgGetError())
        {
        case VG_BAD_HANDLE_ERROR:
            return (VGU_BAD_HANDLE_ERROR);

        case VG_PATH_CAPABILITY_ERROR:
            return (VGU_PATH_CAPABILITY_ERROR);

        case VG_OUT_OF_MEMORY_ERROR:
            return (VGU_OUT_OF_MEMORY_ERROR);

        default:
            return (VGU_NO_ERROR);
        }
    }
